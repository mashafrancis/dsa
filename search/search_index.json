{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"naming/","text":"Naming \u00b6 I am not the original author of this document. This is borrowed from @walkccc . See the definition of Convention over configuration in Wikipedia . Fundamental \u00b6 Rules \u00b6 Class : UpperCamelCase Function : lowerCamelCase Variable : lowerCamelCase Constant : UPPERCASE with underline Field : lowerCamelCase Database : SELECT * FROM name_table Examples \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Class class MyClass { ... } // Function function myFunction () { ... } // Variable int myVariable ; // Constant #define MY_CONSTANT; // Database Table SELECT * FROM my_table Template \u00b6 Rules \u00b6 There should only be one public function. Declare the variables in the proper scope as slow as possible. Declare ans as soon as possible. Since LeetCode is just an online judge system rather than a big project, we don't scatter all variables in different sections. However, we still sort the variables based on the time we first use each of them. Code section (there should be one blank line between each sections.) public boundary conditions initial variables There may be many kernels separated with one blank line, but there shouldn't be any blank line in each kernel. return private private variables private function(s) Schematic Template \u00b6 We use C++ to demo the idea. Blank one single line between each section. However, if there\u2019s no sec 12 , no blank line between sec 11 and sec 13 . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : // There should only be one public function. func () { // (sec 0) boundary conditions // (sec 1) initial variables // (sec 10) constexpr/const (size/length) // (sec 11) ans // (sec 12) declaration & operation // (sec 13) purely declaration // (sec 2) kernels // (sec 3) modify original initial variables // (sec 4) kernels // (sec n) return } private : // private variables // private function(s) helper () { ... } dfs () { ... } }; Example ( 873. Length of Longest Fibonacci Subsequence ): code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < n ; ++ i ) numToIndex [ A [ i ]] = i ; for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { const int ai = A [ k ] - A [ j ]; if ( ai < A [ j ] && numToIndex . count ( ai )) { const int i = numToIndex [ ai ]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } }; code (explanation): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { // Only get the value of size or length // when we use it twice or more times. // Add `const`, and separate this line from next section a blank line. const int n = A . size (); // Declare the variables in the proper scope as slow as possible. // Declare `ans` as soon as possible. // Order: ans -> dp -> STL -> pointers (TBD) int ans = 0 ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < n ; ++ i ) numToIndex [ A [ i ]] = i ; for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { const int ai = A [ k ] - A [ j ]; // use const if ( ai < A [ j ] && numToIndex . count ( ai )) { const int i = numToIndex [ ai ]; // use const dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } }; Boundary Conditions \u00b6 1 2 3 4 5 6 7 8 9 10 // Linked-List if ( l1 || l2 ) { ... } if ( ! l1 || ! l2 ) { ... } // String if ( str . empty ()) { ... } if ( str . length () <= 2 ) { ... } // Vector if ( vec . size () <= 2 ) { ... } Return Value \u00b6 1 2 return ans ; return {}; Data Structures \u00b6 1 2 3 4 5 6 7 8 9 10 11 // C++ unordered_set < string > seen ; unordered_map < char , int > count ; // numToIndex, prefixToIndex vector < int > count ; // sometimes it's a better choice than `unordered_map` stack < char > stack ; queue < TreeNode *> q ; deque < TreeNode *> deque ; auto compare = []( const ListNode * a , const ListNode * b ) { return a -> val > b -> val ; }; priority_queue < ListNode * , vector < ListNode *> , decltype ( compare ) > pq ( compare ); 1 2 3 4 5 6 7 8 // Java Set < String > seen = new HashSet <> (); Map < Character , Integer > count = new HashMap <> (); int [] count = new int [ n ] ; Stack < Character > stack = new Stack <> (); Queue < Integer > q = new LinkedList <> (); Deque < Integer > deque = new ArrayDeque <> (); Queue < ListNode > pq = new PriorityQueue <> (( a , b ) -> a . val - b . val ); 1 2 3 4 5 6 7 8 9 # Python seen = set () # or wordSet = set() if you like count = {} count = collections . defaultdict ( int ) count = collections . defaultdict ( list ) count = collections . Counter () q = collections . deque ([ root ]) deque = collections . deque ([ root ]) stack = [] Two Pointers / Sliding Windows \u00b6 Always prefer to one character to represent index variables. Use i , j , k in the loop, in that order. 1 2 int i = 0 ; for ( const int num : nums ) { ... } 1 for ( int i = 0 , j = 0 ; i < n ; ++ i ) { ... } 1 2 3 int k = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = i ; j < n ; ++ j ) { ... } 1 2 int l = 0 ; int r = nums . size () - 1 ; Binary Search \u00b6 Always prefer to one character to represent index variables. Always prefer to use [l, r) pattern. 1 2 3 4 5 6 7 8 9 10 11 12 13 int l = 0 ; int r = nums . size (); // or nums.size() - 1 while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( f ( m )) return m ; // optional if ( g ( m )) l = m + 1 ; // new range [m + 1, r) else r = m ; // new range [l, m) } return l ; // nums[l] ListNode \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ListNode dummy ( 0 ); // allocated on stack instead of heap ListNode * curr ; ListNode * prev ; ListNode * next ; ListNode * slow ; ListNode * fast ; ListNode * head ; ListNode * tail ; ListNode * l1 ; ListNode * l2 ; 2D Vector / 2 Strings \u00b6 1 2 3 4 5 6 7 8 9 10 // 2D Vector const int m = matrix . size (); const int n = matrix [ 0 ]. size (); // if there're two strings const int m = str1 . length (); const int n = str2 . length (); // if there's only a string const int n = str . length (); Traversing \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // vector<int> nums; for ( int i = 0 ; i < nums . size (); ++ i ) { ... } for ( const int num : nums ) { ... } // vector<string> words; for ( const string & word : words ) { ... } // string str; for ( int i = 0 ; i < str . length (); ++ i ) { ... } for ( const char c : str ) { ... } // unordered_set<int> set; for ( const int num : set ) { ... } // structured binding // unordered_map<char, int> map; for ( const auto & [ key , value ] : map ) { ... } // ListNode* head; for ( ListNode * curr = head ; curr ; curr = curr -> next ) { ... } Others \u00b6 Always prefer to use str.length() over str.size() . Always use camelCase nomenclature when not listed above. 1 2 3 4 // C++ int currNum ; int maxProfit ; TreeNode * currNode ; When there's confliction in expression and function or reserved key word: 1 2 3 // C++ mini , std :: min () maxi , std :: max () 1 2 3 4 # Python mini , min maxi , max summ , sum When there are two maps/stacks, use meaningful names. 1 2 3 // C++ unordered_map < char , int > countA ; unordered_map < char , int > countB ; When we need to count something, use sum , count and total , in that order. Initialize vector with 0 or false implicitly . (TBD) constexpr is used if possible. const is used if we get value of size() or length() . const auto is used when we iterate through a map Use & whenever possible except int and char because reference typically takes 4 bytes, while int takes 2/4 bytes and char takes 1 byte Prefer to name variables in a \"adjactive + noun\" order. For example, maxLeft is better than leftMax .","title":"Naming"},{"location":"naming/#naming","text":"I am not the original author of this document. This is borrowed from @walkccc . See the definition of Convention over configuration in Wikipedia .","title":"Naming"},{"location":"naming/#fundamental","text":"","title":"Fundamental"},{"location":"naming/#rules","text":"Class : UpperCamelCase Function : lowerCamelCase Variable : lowerCamelCase Constant : UPPERCASE with underline Field : lowerCamelCase Database : SELECT * FROM name_table","title":"Rules"},{"location":"naming/#examples","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Class class MyClass { ... } // Function function myFunction () { ... } // Variable int myVariable ; // Constant #define MY_CONSTANT; // Database Table SELECT * FROM my_table","title":"Examples"},{"location":"naming/#template","text":"","title":"Template"},{"location":"naming/#rules_1","text":"There should only be one public function. Declare the variables in the proper scope as slow as possible. Declare ans as soon as possible. Since LeetCode is just an online judge system rather than a big project, we don't scatter all variables in different sections. However, we still sort the variables based on the time we first use each of them. Code section (there should be one blank line between each sections.) public boundary conditions initial variables There may be many kernels separated with one blank line, but there shouldn't be any blank line in each kernel. return private private variables private function(s)","title":"Rules"},{"location":"naming/#schematic-template","text":"We use C++ to demo the idea. Blank one single line between each section. However, if there\u2019s no sec 12 , no blank line between sec 11 and sec 13 . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : // There should only be one public function. func () { // (sec 0) boundary conditions // (sec 1) initial variables // (sec 10) constexpr/const (size/length) // (sec 11) ans // (sec 12) declaration & operation // (sec 13) purely declaration // (sec 2) kernels // (sec 3) modify original initial variables // (sec 4) kernels // (sec n) return } private : // private variables // private function(s) helper () { ... } dfs () { ... } }; Example ( 873. Length of Longest Fibonacci Subsequence ): code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < n ; ++ i ) numToIndex [ A [ i ]] = i ; for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { const int ai = A [ k ] - A [ j ]; if ( ai < A [ j ] && numToIndex . count ( ai )) { const int i = numToIndex [ ai ]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } }; code (explanation): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { // Only get the value of size or length // when we use it twice or more times. // Add `const`, and separate this line from next section a blank line. const int n = A . size (); // Declare the variables in the proper scope as slow as possible. // Declare `ans` as soon as possible. // Order: ans -> dp -> STL -> pointers (TBD) int ans = 0 ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < n ; ++ i ) numToIndex [ A [ i ]] = i ; for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { const int ai = A [ k ] - A [ j ]; // use const if ( ai < A [ j ] && numToIndex . count ( ai )) { const int i = numToIndex [ ai ]; // use const dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } };","title":"Schematic Template"},{"location":"naming/#boundary-conditions","text":"1 2 3 4 5 6 7 8 9 10 // Linked-List if ( l1 || l2 ) { ... } if ( ! l1 || ! l2 ) { ... } // String if ( str . empty ()) { ... } if ( str . length () <= 2 ) { ... } // Vector if ( vec . size () <= 2 ) { ... }","title":"Boundary Conditions"},{"location":"naming/#return-value","text":"1 2 return ans ; return {};","title":"Return Value"},{"location":"naming/#data-structures","text":"1 2 3 4 5 6 7 8 9 10 11 // C++ unordered_set < string > seen ; unordered_map < char , int > count ; // numToIndex, prefixToIndex vector < int > count ; // sometimes it's a better choice than `unordered_map` stack < char > stack ; queue < TreeNode *> q ; deque < TreeNode *> deque ; auto compare = []( const ListNode * a , const ListNode * b ) { return a -> val > b -> val ; }; priority_queue < ListNode * , vector < ListNode *> , decltype ( compare ) > pq ( compare ); 1 2 3 4 5 6 7 8 // Java Set < String > seen = new HashSet <> (); Map < Character , Integer > count = new HashMap <> (); int [] count = new int [ n ] ; Stack < Character > stack = new Stack <> (); Queue < Integer > q = new LinkedList <> (); Deque < Integer > deque = new ArrayDeque <> (); Queue < ListNode > pq = new PriorityQueue <> (( a , b ) -> a . val - b . val ); 1 2 3 4 5 6 7 8 9 # Python seen = set () # or wordSet = set() if you like count = {} count = collections . defaultdict ( int ) count = collections . defaultdict ( list ) count = collections . Counter () q = collections . deque ([ root ]) deque = collections . deque ([ root ]) stack = []","title":"Data Structures"},{"location":"naming/#two-pointers-sliding-windows","text":"Always prefer to one character to represent index variables. Use i , j , k in the loop, in that order. 1 2 int i = 0 ; for ( const int num : nums ) { ... } 1 for ( int i = 0 , j = 0 ; i < n ; ++ i ) { ... } 1 2 3 int k = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = i ; j < n ; ++ j ) { ... } 1 2 int l = 0 ; int r = nums . size () - 1 ;","title":"Two Pointers / Sliding Windows"},{"location":"naming/#binary-search","text":"Always prefer to one character to represent index variables. Always prefer to use [l, r) pattern. 1 2 3 4 5 6 7 8 9 10 11 12 13 int l = 0 ; int r = nums . size (); // or nums.size() - 1 while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( f ( m )) return m ; // optional if ( g ( m )) l = m + 1 ; // new range [m + 1, r) else r = m ; // new range [l, m) } return l ; // nums[l]","title":"Binary Search"},{"location":"naming/#listnode","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 ListNode dummy ( 0 ); // allocated on stack instead of heap ListNode * curr ; ListNode * prev ; ListNode * next ; ListNode * slow ; ListNode * fast ; ListNode * head ; ListNode * tail ; ListNode * l1 ; ListNode * l2 ;","title":"ListNode"},{"location":"naming/#2d-vector-2-strings","text":"1 2 3 4 5 6 7 8 9 10 // 2D Vector const int m = matrix . size (); const int n = matrix [ 0 ]. size (); // if there're two strings const int m = str1 . length (); const int n = str2 . length (); // if there's only a string const int n = str . length ();","title":"2D Vector / 2 Strings"},{"location":"naming/#traversing","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // vector<int> nums; for ( int i = 0 ; i < nums . size (); ++ i ) { ... } for ( const int num : nums ) { ... } // vector<string> words; for ( const string & word : words ) { ... } // string str; for ( int i = 0 ; i < str . length (); ++ i ) { ... } for ( const char c : str ) { ... } // unordered_set<int> set; for ( const int num : set ) { ... } // structured binding // unordered_map<char, int> map; for ( const auto & [ key , value ] : map ) { ... } // ListNode* head; for ( ListNode * curr = head ; curr ; curr = curr -> next ) { ... }","title":"Traversing"},{"location":"naming/#others","text":"Always prefer to use str.length() over str.size() . Always use camelCase nomenclature when not listed above. 1 2 3 4 // C++ int currNum ; int maxProfit ; TreeNode * currNode ; When there's confliction in expression and function or reserved key word: 1 2 3 // C++ mini , std :: min () maxi , std :: max () 1 2 3 4 # Python mini , min maxi , max summ , sum When there are two maps/stacks, use meaningful names. 1 2 3 // C++ unordered_map < char , int > countA ; unordered_map < char , int > countB ; When we need to count something, use sum , count and total , in that order. Initialize vector with 0 or false implicitly . (TBD) constexpr is used if possible. const is used if we get value of size() or length() . const auto is used when we iterate through a map Use & whenever possible except int and char because reference typically takes 4 bytes, while int takes 2/4 bytes and char takes 1 byte Prefer to name variables in a \"adjactive + noun\" order. For example, maxLeft is better than leftMax .","title":"Others"},{"location":"preface/","text":"LeetCode Solutions \ud83d\udca1 Solutions to LeetCode in C++, Java, and Python. This repository aims to provide code with good readability and consistent style over various topics and embraces new standards. Getting Started \u00b6 See the built page here: LeetCode Solutions . Coding Style \u00b6 I believe messy code is costing you. Therefore, I follow the formatter 99% of the time, but in rare situations, I format the code manually because it might look better in these cases. Also, I don't squeeze everything in a single line just to save vertical rows since this disrespects the column limit and makes the code hard to read. Here's a more detailed style guide . Formatting \u00b6 C++ code is formatted by clang-format following the Google C++ Style Guide . You can see the configuration here . Java code is formatted by clang-format following the Google Java Style Guide . Python code is formatted by autopep8 following PEP 8 -- Style Guide for Python Code except passing the argument --indent-size=2 for a better viewing experience in mobile devices. Take a look at my nvim configuration related to auto formatting. ~/.config/nvim/init.lua ~/.config/nvim/lua/plugins.lua : ~/.config/nvim/lua/plugins/null-ls.lua","title":"Preface"},{"location":"preface/#getting-started","text":"See the built page here: LeetCode Solutions .","title":"Getting Started"},{"location":"preface/#coding-style","text":"I believe messy code is costing you. Therefore, I follow the formatter 99% of the time, but in rare situations, I format the code manually because it might look better in these cases. Also, I don't squeeze everything in a single line just to save vertical rows since this disrespects the column limit and makes the code hard to read. Here's a more detailed style guide .","title":"Coding Style"},{"location":"preface/#formatting","text":"C++ code is formatted by clang-format following the Google C++ Style Guide . You can see the configuration here . Java code is formatted by clang-format following the Google Java Style Guide . Python code is formatted by autopep8 following PEP 8 -- Style Guide for Python Code except passing the argument --indent-size=2 for a better viewing experience in mobile devices. Take a look at my nvim configuration related to auto formatting. ~/.config/nvim/init.lua ~/.config/nvim/lua/plugins.lua : ~/.config/nvim/lua/plugins/null-ls.lua","title":"Formatting"},{"location":"styleguide/","text":"Style Guide \u00b6 This document is discussed with @hsins . See the definition of Convention over configuration in Wikipedia . Disclaimer \u00b6 General \u00b6 We adopt lowerCamelCase for both functions and variables, which is against the rule of Google C++ Style Guide and PEP 8 -- Style Guide for Python Code . However, to be consistent with the LeetCode OJ system, which uses lowerCamelCase for over 99% of the time, we stick with lowerCamelCase in this case. Remember the most important thing is to be consistent all the time. We omit importing and brackets, and this is for shorter paragraph. In a real situation, retain importing let you quickly know where is this function/variable from and brackets make the indentation safer, so you might keep both of them. C++ \u00b6 Code can't be compiled, it's just for demonstrating purposes. Even though there is auto keyword in C++ 11 , for types like int and char , we tend to explicitly declare them. However, you might use auto most of the time in the real world. We skip including. We use int to traverse the array most of the time for simplicity. However, you should note the difference between size_t and int , and in the real world, that matters. We omit std:: to access the standard library for a short paragraph. Java \u00b6 Code can't be compiled, it's just for demonstrating purposes. Even though there is var keyword in Java, for types like int and char , we tend to explicitly declare them so people can have an idea of what the type is at first glance. We skip importing. Python \u00b6 We omit prefixes like collections. and math. . However, this might not be a good practice. Just want to keep the paragraph short. We prefix private functions with _ and this might seem tedious. However, we tend to use something like Mypy and Pyre to do static type checking in the real world. We pass the argument --indent-size=2 to autopep8 for a better viewing experience. Fundamental \u00b6 Rules \u00b6 Class : UpperCamelCase Function : lowerCamelCase Variable : lowerCamelCase Constant : UPPERCASE with underline Field : lowerCamelCase Database : SELECT * FROM name_table Examples \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Class class MyClass { ... } // Function function myFunction () { ... } // Variable int myVariable ; // Constant #define MY_CONSTANT; // Database Table SELECT * FROM my_table Template \u00b6 Rules \u00b6 There should only be one public function. Declare the variables in the proper scope as slow as possible. Declare const variables as soon as possible. Declare ans as soon as possible. Since LeetCode is just an online judge system rather than a big project, we don't scatter all variables in different sections. However, we still sort the variables based on the time we first use each of them. Code section (there should be one blank line between each sections.) public boundary conditions initial variables There may be many kernels separated with one blank line, but there shouldn't be any blank line in each kernel. return private private variables private function(s) Schematic Template \u00b6 We use C++ to demo the idea. No blank lines between variables initialization. Blank one single line between each section. However, if there's no sec 12 , no blank line between sec 11 and sec 13 . If the last statement is not a paragraph ( for loop most of the case), then no blank lines between it and the return statement. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : // There should only be one public function. func () { // (sec 0) boundary conditions // (sec 1) initial variables // (sec 10) constexpr/const (size/length) // (sec 11) ans // (sec 12) declaration & operation // (sec 13) purely declaration // (sec 2) kernels // (sec 3) modify original initial variables // (sec 4) kernels // (sec n) return } private : // private variables // private function(s) helper () { ... } dfs () { ... } }; Example ( 873. Length of Longest Fibonacci Subsequence ): code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < n ; ++ i ) numToIndex [ A [ i ]] = i ; for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { const int ai = A [ k ] - A [ j ]; if ( ai < A [ j ] && numToIndex . count ( ai )) { const int i = numToIndex [ ai ]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } }; code (explanation): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { // Only get the value of size or length // when we use it twice or more times. // Add `const`, and separate this line from next section a blank line. const int n = A . size (); // Declare the variables in the proper scope as slow as possible. // Declare `ans` as soon as possible. // General Order: // ans -> dp -> STL -> pointers (TBD) // // Graph Order: // ans -> graph -> inDegree -> state -> q -> seen int ans = 0 ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < n ; ++ i ) numToIndex [ A [ i ]] = i ; for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { const int ai = A [ k ] - A [ j ]; // use const if ( ai < A [ j ] && numToIndex . count ( ai )) { const int i = numToIndex [ ai ]; // use const dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } }; Boundary Conditions \u00b6 1 2 3 4 5 6 7 8 9 10 // Linked-List if ( l1 == nullptr && l2 == nullptr ) { ... } if ( l1 != nullptr || l2 != nullptr ) { ... } // String if ( str . empty ()) { ... } if ( str . length () <= 2 ) { ... } // Vector if ( vec . size () <= 2 ) { ... } Return Value \u00b6 1 2 return ans ; return {}; Data Structures \u00b6 1 2 3 4 5 6 7 8 9 10 11 // C++ unordered_set < string > seen ; unordered_map < char , int > count ; // numToIndex, prefixToIndex vector < int > count ; // sometimes it's a better choice than `unordered_map` stack < char > stack ; queue < TreeNode *> q ; deque < TreeNode *> q ; auto compare = []( const ListNode * a , const ListNode * b ) { return a -> val > b -> val ; }; priority_queue < ListNode * , vector < ListNode *> , decltype ( compare ) > minHeap ( compare ); 1 2 3 4 5 6 7 8 // Java Set < String > seen = new HashSet <> (); Map < Character , Integer > count = new HashMap <> (); int [] count = new int [ n ] ; Stack < Character > stack = new Stack <> (); Queue < Integer > q = new LinkedList <> (); Deque < Integer > q = new ArrayDeque <> (); Queue < ListNode > minHeap = new PriorityQueue <> (( a , b ) -> a . val - b . val ); 1 2 3 4 5 6 7 8 9 10 # Python seen = set () # or wordSet = set() if you like count = {} count = collections . defaultdict ( int ) count = collections . defaultdict ( list ) count = collections . Counter () q = collections . deque ([ root ]) q = collections . deque ([ root ]) stack = [] minHeap = [] Two Pointers / Sliding Windows \u00b6 Always prefer to one character to represent index variables. Use i , j , k in the loop, in that order. 1 2 int i = 0 ; for ( const int num : nums ) { ... } 1 for ( int i = 0 , j = 0 ; i < n ; ++ i ) { ... } 1 2 3 int k = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = i ; j < n ; ++ j ) { ... } 1 2 int l = 0 ; int r = nums . size () - 1 ; Binary Search \u00b6 Always prefer to one character to represent index variables. Always prefer to use [l, r) pattern. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int l = 0 ; int r = nums . size (); // or nums.size() - 1 while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( f ( m )) // optional return m ; // optional if ( g ( m )) l = m + 1 ; // new range [m + 1, r) else r = m ; // new range [l, m) } return l ; // nums[l] ListNode \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ListNode dummy ( 0 ); // allocated on stack instead of heap ListNode * curr ; ListNode * prev ; ListNode * next ; ListNode * slow ; ListNode * fast ; ListNode * head ; ListNode * tail ; ListNode * l1 ; ListNode * l2 ; 2D Vector / 2 Strings \u00b6 1 2 3 4 5 6 7 8 9 10 // 2D Vector const int m = matrix . size (); const int n = matrix [ 0 ]. size (); // if there're two strings const int m = str1 . length (); const int n = str2 . length (); // if there's only a string const int n = str . length (); Traversing \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // vector<int> nums; for ( int i = 0 ; i < nums . size (); ++ i ) { ... } for ( const int num : nums ) { ... } // vector<string> words; for ( const auto & word : words ) { ... } // string str; for ( int i = 0 ; i < str . length (); ++ i ) { ... } for ( const char c : str ) { ... } // unordered_set<int> numsSet; for ( const int num : numsSet ) { ... } // structured binding // unordered_map<char, int> map; for ( const auto & [ key , value ] : map ) { ... } // ListNode* head; for ( auto curr = head ; curr ; curr = curr -> next ) { ... } Others \u00b6 Always prefer to use str.length() over str.size() . Always use camelCase nomenclature when not listed above. 1 2 3 4 // C++ int currNum ; int maxProfit ; TreeNode * currNode ; When there's confliction in expression and function or reserved key word: 1 2 3 // C++ mini , std :: min () maxi , std :: max () 1 2 3 4 # Python mini , min maxi , max summ , sum When there are two maps/stacks, use meaningful names. 1 2 3 // C++ unordered_map < char , int > countA ; unordered_map < char , int > countB ; When we need to count something, use sum , count and total , in that order. Initialize vector with 0 or false implicitly . constexpr is used if possible. const is used if we get value of size() or length() . const auto is used when we iterate through a map . Use & whenever possible except int and char because reference typically takes 4 bytes, while int takes 2/4 bytes and char takes 1 byte. Prefer to name variables in a \"adjective + noun\" order. For example, maxLeft is better than leftMax . If a block is really small, for example, before a bfs() call, sometimes we don't add extra blank lines.","title":"Style Guide"},{"location":"styleguide/#style-guide","text":"This document is discussed with @hsins . See the definition of Convention over configuration in Wikipedia .","title":"Style Guide"},{"location":"styleguide/#disclaimer","text":"","title":"Disclaimer"},{"location":"styleguide/#general","text":"We adopt lowerCamelCase for both functions and variables, which is against the rule of Google C++ Style Guide and PEP 8 -- Style Guide for Python Code . However, to be consistent with the LeetCode OJ system, which uses lowerCamelCase for over 99% of the time, we stick with lowerCamelCase in this case. Remember the most important thing is to be consistent all the time. We omit importing and brackets, and this is for shorter paragraph. In a real situation, retain importing let you quickly know where is this function/variable from and brackets make the indentation safer, so you might keep both of them.","title":"General"},{"location":"styleguide/#c","text":"Code can't be compiled, it's just for demonstrating purposes. Even though there is auto keyword in C++ 11 , for types like int and char , we tend to explicitly declare them. However, you might use auto most of the time in the real world. We skip including. We use int to traverse the array most of the time for simplicity. However, you should note the difference between size_t and int , and in the real world, that matters. We omit std:: to access the standard library for a short paragraph.","title":"C++"},{"location":"styleguide/#java","text":"Code can't be compiled, it's just for demonstrating purposes. Even though there is var keyword in Java, for types like int and char , we tend to explicitly declare them so people can have an idea of what the type is at first glance. We skip importing.","title":"Java"},{"location":"styleguide/#python","text":"We omit prefixes like collections. and math. . However, this might not be a good practice. Just want to keep the paragraph short. We prefix private functions with _ and this might seem tedious. However, we tend to use something like Mypy and Pyre to do static type checking in the real world. We pass the argument --indent-size=2 to autopep8 for a better viewing experience.","title":"Python"},{"location":"styleguide/#fundamental","text":"","title":"Fundamental"},{"location":"styleguide/#rules","text":"Class : UpperCamelCase Function : lowerCamelCase Variable : lowerCamelCase Constant : UPPERCASE with underline Field : lowerCamelCase Database : SELECT * FROM name_table","title":"Rules"},{"location":"styleguide/#examples","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Class class MyClass { ... } // Function function myFunction () { ... } // Variable int myVariable ; // Constant #define MY_CONSTANT; // Database Table SELECT * FROM my_table","title":"Examples"},{"location":"styleguide/#template","text":"","title":"Template"},{"location":"styleguide/#rules_1","text":"There should only be one public function. Declare the variables in the proper scope as slow as possible. Declare const variables as soon as possible. Declare ans as soon as possible. Since LeetCode is just an online judge system rather than a big project, we don't scatter all variables in different sections. However, we still sort the variables based on the time we first use each of them. Code section (there should be one blank line between each sections.) public boundary conditions initial variables There may be many kernels separated with one blank line, but there shouldn't be any blank line in each kernel. return private private variables private function(s)","title":"Rules"},{"location":"styleguide/#schematic-template","text":"We use C++ to demo the idea. No blank lines between variables initialization. Blank one single line between each section. However, if there's no sec 12 , no blank line between sec 11 and sec 13 . If the last statement is not a paragraph ( for loop most of the case), then no blank lines between it and the return statement. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : // There should only be one public function. func () { // (sec 0) boundary conditions // (sec 1) initial variables // (sec 10) constexpr/const (size/length) // (sec 11) ans // (sec 12) declaration & operation // (sec 13) purely declaration // (sec 2) kernels // (sec 3) modify original initial variables // (sec 4) kernels // (sec n) return } private : // private variables // private function(s) helper () { ... } dfs () { ... } }; Example ( 873. Length of Longest Fibonacci Subsequence ): code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < n ; ++ i ) numToIndex [ A [ i ]] = i ; for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { const int ai = A [ k ] - A [ j ]; if ( ai < A [ j ] && numToIndex . count ( ai )) { const int i = numToIndex [ ai ]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } }; code (explanation): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { // Only get the value of size or length // when we use it twice or more times. // Add `const`, and separate this line from next section a blank line. const int n = A . size (); // Declare the variables in the proper scope as slow as possible. // Declare `ans` as soon as possible. // General Order: // ans -> dp -> STL -> pointers (TBD) // // Graph Order: // ans -> graph -> inDegree -> state -> q -> seen int ans = 0 ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < n ; ++ i ) numToIndex [ A [ i ]] = i ; for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { const int ai = A [ k ] - A [ j ]; // use const if ( ai < A [ j ] && numToIndex . count ( ai )) { const int i = numToIndex [ ai ]; // use const dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } };","title":"Schematic Template"},{"location":"styleguide/#boundary-conditions","text":"1 2 3 4 5 6 7 8 9 10 // Linked-List if ( l1 == nullptr && l2 == nullptr ) { ... } if ( l1 != nullptr || l2 != nullptr ) { ... } // String if ( str . empty ()) { ... } if ( str . length () <= 2 ) { ... } // Vector if ( vec . size () <= 2 ) { ... }","title":"Boundary Conditions"},{"location":"styleguide/#return-value","text":"1 2 return ans ; return {};","title":"Return Value"},{"location":"styleguide/#data-structures","text":"1 2 3 4 5 6 7 8 9 10 11 // C++ unordered_set < string > seen ; unordered_map < char , int > count ; // numToIndex, prefixToIndex vector < int > count ; // sometimes it's a better choice than `unordered_map` stack < char > stack ; queue < TreeNode *> q ; deque < TreeNode *> q ; auto compare = []( const ListNode * a , const ListNode * b ) { return a -> val > b -> val ; }; priority_queue < ListNode * , vector < ListNode *> , decltype ( compare ) > minHeap ( compare ); 1 2 3 4 5 6 7 8 // Java Set < String > seen = new HashSet <> (); Map < Character , Integer > count = new HashMap <> (); int [] count = new int [ n ] ; Stack < Character > stack = new Stack <> (); Queue < Integer > q = new LinkedList <> (); Deque < Integer > q = new ArrayDeque <> (); Queue < ListNode > minHeap = new PriorityQueue <> (( a , b ) -> a . val - b . val ); 1 2 3 4 5 6 7 8 9 10 # Python seen = set () # or wordSet = set() if you like count = {} count = collections . defaultdict ( int ) count = collections . defaultdict ( list ) count = collections . Counter () q = collections . deque ([ root ]) q = collections . deque ([ root ]) stack = [] minHeap = []","title":"Data Structures"},{"location":"styleguide/#two-pointers-sliding-windows","text":"Always prefer to one character to represent index variables. Use i , j , k in the loop, in that order. 1 2 int i = 0 ; for ( const int num : nums ) { ... } 1 for ( int i = 0 , j = 0 ; i < n ; ++ i ) { ... } 1 2 3 int k = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = i ; j < n ; ++ j ) { ... } 1 2 int l = 0 ; int r = nums . size () - 1 ;","title":"Two Pointers / Sliding Windows"},{"location":"styleguide/#binary-search","text":"Always prefer to one character to represent index variables. Always prefer to use [l, r) pattern. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int l = 0 ; int r = nums . size (); // or nums.size() - 1 while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( f ( m )) // optional return m ; // optional if ( g ( m )) l = m + 1 ; // new range [m + 1, r) else r = m ; // new range [l, m) } return l ; // nums[l]","title":"Binary Search"},{"location":"styleguide/#listnode","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 ListNode dummy ( 0 ); // allocated on stack instead of heap ListNode * curr ; ListNode * prev ; ListNode * next ; ListNode * slow ; ListNode * fast ; ListNode * head ; ListNode * tail ; ListNode * l1 ; ListNode * l2 ;","title":"ListNode"},{"location":"styleguide/#2d-vector-2-strings","text":"1 2 3 4 5 6 7 8 9 10 // 2D Vector const int m = matrix . size (); const int n = matrix [ 0 ]. size (); // if there're two strings const int m = str1 . length (); const int n = str2 . length (); // if there's only a string const int n = str . length ();","title":"2D Vector / 2 Strings"},{"location":"styleguide/#traversing","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // vector<int> nums; for ( int i = 0 ; i < nums . size (); ++ i ) { ... } for ( const int num : nums ) { ... } // vector<string> words; for ( const auto & word : words ) { ... } // string str; for ( int i = 0 ; i < str . length (); ++ i ) { ... } for ( const char c : str ) { ... } // unordered_set<int> numsSet; for ( const int num : numsSet ) { ... } // structured binding // unordered_map<char, int> map; for ( const auto & [ key , value ] : map ) { ... } // ListNode* head; for ( auto curr = head ; curr ; curr = curr -> next ) { ... }","title":"Traversing"},{"location":"styleguide/#others","text":"Always prefer to use str.length() over str.size() . Always use camelCase nomenclature when not listed above. 1 2 3 4 // C++ int currNum ; int maxProfit ; TreeNode * currNode ; When there's confliction in expression and function or reserved key word: 1 2 3 // C++ mini , std :: min () maxi , std :: max () 1 2 3 4 # Python mini , min maxi , max summ , sum When there are two maps/stacks, use meaningful names. 1 2 3 // C++ unordered_map < char , int > countA ; unordered_map < char , int > countB ; When we need to count something, use sum , count and total , in that order. Initialize vector with 0 or false implicitly . constexpr is used if possible. const is used if we get value of size() or length() . const auto is used when we iterate through a map . Use & whenever possible except int and char because reference typically takes 4 bytes, while int takes 2/4 bytes and char takes 1 byte. Prefer to name variables in a \"adjective + noun\" order. For example, maxLeft is better than leftMax . If a block is really small, for example, before a bfs() call, sometimes we don't add extra blank lines.","title":"Others"}]}